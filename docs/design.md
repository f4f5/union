## 连接器
连接器是一个独立的进程，它将帮助更新和维护资源定位表，并帮助调度客户端的连接。资源定位表包含Union中每个服务的所有信息。因为整个网络是动态的，所以这个文件也会随时间变化。连接器将帮助进行资源定位表的增、删、改、查。资源定位表将按IP、服务类型、端口、剩余连接、位置等描述服务。资源定位表内容如下：

```
resource_mains:    //主资源文件
{
    ip_x: {
        ip:
        server_type: []
        remain_connections: []
        score:
        location:
    }    
}
locations:   //下面的数据结构帮助更快的搜索资源
{
    location_x: {  //是该按国家进行划分吗？ 待定
        ip:
    }
}

scores: [1st ip, 2ed ip, 3rd ip, 4th ip, ...]  //前100个性能最好的主机

server_types:
{
    type_x: [ip_x]
}

remainconnections:{
    unremain: [],
    remain10: [],
    remain100: [],
    remain1000: [],
    remain10000: [],
    unlimit: []
}

```

连接器将自动选择前100个SOCRE最高的计算机作为主节点。score越高意味着电脑在各种操作中都很快。经过一段时间后，普通节点将随机选择一个主节点来更新其资源定位表（如果需要）。

***删除失败的节点***

有两种状况，一个是失效节点是主节点，另一个是失效节点是普通节点。

*主节点故障*

* 如果失败的节点是主节点，当普通节点周期性地请求其父节点维持心跳时（该节点先前连接的主节点是父节点），如果请求被阻止，该节点将选择另一个主节点并将被阻止的主节点（原 父节点）报告给所选的主节点，然后所选的主节点将检查这个被阻塞的主节点状态，并更新资源定位表。为了实现这一点，普通节点会将曾连接的主节点作为其父节点来维护。

*普通节点故障*

* 主节点应该维护一个包含其所有子节点及其最新连接时间的表。如果心跳时间超出范围，父节点将尝试连接此节点并进行检查。如果失败，删除它，更新资源定位表。

***添加新节点***

* 如果一个新节点想要加入网络，它必须至少知道这个网络的一个节点的地址（IP，端口）。首先，它连接到该地址，并检索资源定位表。其次，根据当前资源定位表选择一个主节点，并连接到主节点。最后，在主节点接收到这些信息后，它将更新资源定位表。

***更新资源定位表***

* 只有主节点可以更新资源定位表。当一个主节点的资源定位表更新后，它将广播到所有主节点，所有主节点进行更新。当一个主节点接收到一个主节点的更新广播时，必须检查更新的节点是否有效，如果一个主节点在1小时内广播10次无效的节点，该节点将被放入一个主节点黑名单中一天。如果一个正常的节点在1小时内重新连接（不稳定）10次，它将在1小时内被此网络阻止。

***路由逻辑***

* 假设一个主节点连接失败，它将被从主节点列表中删除。然后选择一个新节点添加到主节点列表中。首先，新的主节点将没有子节点，因此没有父节点的普通节点将首先选择子节点少的主节点连接。当所有主节点的子节点数量达到一个大致的平衡是，我们就要考虑到主节点与子节点的距离问题。因为子节点与主节点之间的通信是很频繁的，所有选择较近的节点做为主节点是很有必要的。

* 主节点将有自己的容量。所有接收连接的主节点都应该保持某种平衡。应该有一个函数来计算主节点连接的中值点。连接首先遵循就近原则，然后再挑选链接数少的。假设我们有一个函数可以计算正常节点连接到的所有主节点的效率。或者说是，延误率或损失率或它们两者的综合的一个评分，这个评分越低越好或越大越好。这时普通节点应该总是选择最好的主节点连接。算法将是：

```
choose_best_main_node(current_node):
    efficients = []
    for node in main_node_list:
        efficents.push(comprehensive_efficient(current_node, node) )
    index = maxIndexOf(efficients)
    return efficients[index]
```

### 连接器流程设计
`增  删   改   查`

`选择100个资源最优的节点作为主节点`

`每个主节点有n个子节点，每个子节点选取连接最快的主节点作为主节点。主节点才有增删改的权力。`

流程 1: 
* 初始化节点， 加载配置文件，获取本机的配置信息、网络宽带等信息，配置文件描述了服务类型、服务端口等等信息


流程 2:  函数  connect_2_network
* 检查自身，获取相关信息  ...正在做
* 连接上union网络，获取网络上的资源配置表   ... 正在做
* 选择合适的主节点连接，进一步获取信息
* 看看自己是否可以作为主节点

流程3:
* 周期性的上传本节点信息到自己的主节点
* 周期性与主节点同步资源定位表信息
* 如果主节点阻塞， 更换自己的主节点，并且告诉新的主节点 原主节点阻塞

流程4:
* 主节点检查自己的子节点心跳，剔除不活跃的子节点，并向其它主节点同步剔除信息

流程5:
* 主节点之间交互信息

流程6: 
* 删除老的主节点，选择新的主节点




## 交易行的设计（法币）
----
**难点**
* 在不接支付宝等第三方平台API的情况下，如何处理作弊问题？
* 如何保证交易的可信性

**解决方案探讨**
1. 第一个方案
   
<img src="./imgs/pay.png" />

2. 让承兑商提供第三方兑换功能，系统分支进行监控….

## 开发计划

主网站 = {数据库管理网站、历史币价采集网站、 网页提供网站（用户接口）、区块链交互端网站}

在EOS系统中，最主要的是Nodeos，Cleos 与 Keosd都是辅助功能。在Union系统中，AccountDB其实相当于同时充当了Cleos与Keosd的功能。AccountDB、Nodeos、Webserver的关系如下图所示： 

<img src="./imgs/union-web-nodeos.png" />

AccountDB储存了大量用户的私钥信息，所以私钥不适合进行网络传输，而应该直接在本地进行签名。所以，交易的流程大概是这样的： 用户登录WebServer，填写交易信息，交易推送到AccountDB进行签名，此时如果用户的登录信息正确，则找到正确的私钥进行签名。AccountDB再调用Nodeos的RPC Api接口，将数据写入到区块链上。

目前暂时只提供这一条线吧，考虑再三，还是要把WebServer的代码用javascript，为了方便以后的扩展。因为理论上，用户也可以直接保存自己的私钥信息，而不是借助AccountDB。也就是说应该有一条线是WebServer直接与Nodeos交互的，但这是以后再扩展的工作了。

### Account DataBase 

数据库服务部分是由多台主机构成，当然不会比webserver的主机多。每台主机都运行数据库服务，同时也有一个wrap，实现connector功能，还实现与webserver的交互。这个数据库主要保存了账号的私钥部分，当然保存方式是把私钥截断，并与很多无效数据进行混淆。只有webserver提供了可靠的信息，才能从浩如烟海的数据堆中拼凑出正确的私钥。因此，对Account Database的攻击是无效的。

AccountDB集成了Nodeos的RPC Api，也就是在AccountDB里直接会进行交易签名，然后对Nodeos进行远程调用，目前采用的是nodejs，也就是采用官方的SDK， eosjs。

### WebServer
用户登录到webserver后，要想使用钱包转账等功能，会被要求提供另一个账号和密码，该密码是在Account DataBase中找到正确信息的关键。一般的，webserver的常规数据库根据用户账号密码会保存一部分的Account Database中的私钥获取线索。另一部分需要用户输入。

例如，用户输入信息串 S + var  得到的结果hash得到了Account Database中的数据地址，当用户变更S时，可以任意的改变var而得到一个从没被使用过的新位置存放私钥。这就避免了直接用S表示私钥位置的尴尬，因为用户变更S到新值时很可能那个位置已经被别人占用了。当然，私钥很可能是被截断保存的，采用类似的方法可以做到，这里不再具体赘述。

从安全的角度，网络传输可以使用非对称加密，从而保证网络传输过程中的信息安全。只有在上述网络的节点本机上，密钥才可能会被从内存截获。但在保证相关各个环节主机可靠性的基础上，信息的安全性是得到保证的。即使某个节点被完全攻破，数据外泄，也不会产生财务安全问题，除非那些节点在网络上实时的运行时遭受‘监控’才会产生安全问题，但也只是局部的安全问题。

